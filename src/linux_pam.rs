/* automatically generated by rust-bindgen 0.69.1 */

use libc::{uid_t, gid_t, group, passwd, spwd};

pub const PAM_SUCCESS: i32 = 0;
pub const PAM_OPEN_ERR: i32 = 1;
pub const PAM_SYMBOL_ERR: i32 = 2;
pub const PAM_SERVICE_ERR: i32 = 3;
pub const PAM_SYSTEM_ERR: i32 = 4;
pub const PAM_BUF_ERR: i32 = 5;
pub const PAM_PERM_DENIED: i32 = 6;
pub const PAM_AUTH_ERR: i32 = 7;
pub const PAM_CRED_INSUFFICIENT: i32 = 8;
pub const PAM_AUTHINFO_UNAVAIL: i32 = 9;
pub const PAM_USER_UNKNOWN: i32 = 10;
pub const PAM_MAXTRIES: i32 = 11;
pub const PAM_NEW_AUTHTOK_REQD: i32 = 12;
pub const PAM_ACCT_EXPIRED: i32 = 13;
pub const PAM_SESSION_ERR: i32 = 14;
pub const PAM_CRED_UNAVAIL: i32 = 15;
pub const PAM_CRED_EXPIRED: i32 = 16;
pub const PAM_CRED_ERR: i32 = 17;
pub const PAM_NO_MODULE_DATA: i32 = 18;
pub const PAM_CONV_ERR: i32 = 19;
pub const PAM_AUTHTOK_ERR: i32 = 20;
pub const PAM_AUTHTOK_RECOVERY_ERR: i32 = 21;
pub const PAM_AUTHTOK_LOCK_BUSY: i32 = 22;
pub const PAM_AUTHTOK_DISABLE_AGING: i32 = 23;
pub const PAM_TRY_AGAIN: i32 = 24;
pub const PAM_IGNORE: i32 = 25;
pub const PAM_ABORT: i32 = 26;
pub const PAM_AUTHTOK_EXPIRED: i32 = 27;
pub const PAM_MODULE_UNKNOWN: i32 = 28;
pub const PAM_BAD_ITEM: i32 = 29;
pub const PAM_CONV_AGAIN: i32 = 30;
pub const PAM_INCOMPLETE: i32 = 31;
pub const PAM_SILENT: i32 = 32768;
pub const PAM_DISALLOW_NULL_AUTHTOK: i32 = 1;
pub const PAM_ESTABLISH_CRED: i32 = 2;
pub const PAM_DELETE_CRED: i32 = 4;
pub const PAM_REINITIALIZE_CRED: i32 = 8;
pub const PAM_REFRESH_CRED: i32 = 16;
pub const PAM_CHANGE_EXPIRED_AUTHTOK: i32 = 32;
pub const PAM_SERVICE: i32 = 1;
pub const PAM_USER: i32 = 2;
pub const PAM_TTY: i32 = 3;
pub const PAM_RHOST: i32 = 4;
pub const PAM_CONV: i32 = 5;
pub const PAM_AUTHTOK: i32 = 6;
pub const PAM_OLDAUTHTOK: i32 = 7;
pub const PAM_RUSER: i32 = 8;
pub const PAM_USER_PROMPT: i32 = 9;
pub const PAM_FAIL_DELAY: i32 = 10;
pub const PAM_XDISPLAY: i32 = 11;
pub const PAM_XAUTHDATA: i32 = 12;
pub const PAM_AUTHTOK_TYPE: i32 = 13;
pub const PAM_DATA_SILENT: i32 = 1073741824;
pub const PAM_PROMPT_ECHO_OFF: i32 = 1;
pub const PAM_PROMPT_ECHO_ON: i32 = 2;
pub const PAM_ERROR_MSG: i32 = 3;
pub const PAM_TEXT_INFO: i32 = 4;
pub const PAM_RADIO_TYPE: i32 = 5;
pub const PAM_BINARY_PROMPT: i32 = 7;
pub const PAM_MAX_NUM_MSG: i32 = 32;
pub const PAM_MAX_MSG_SIZE: i32 = 512;
pub const PAM_MAX_RESP_SIZE: i32 = 512;
pub const PAM_AUTHTOK_RECOVER_ERR: i32 = 21;
pub const PAM_BP_MAX_LENGTH: i32 = 131072;
pub const PAM_BPC_FALSE: i32 = 0;
pub const PAM_BPC_TRUE: i32 = 1;
pub const PAM_BPC_OK: i32 = 1;
pub const PAM_BPC_SELECT: i32 = 2;
pub const PAM_BPC_DONE: i32 = 3;
pub const PAM_BPC_FAIL: i32 = 4;
pub const PAM_BPC_GETENV: i32 = 65;
pub const PAM_BPC_PUTENV: i32 = 66;
pub const PAM_BPC_TEXT: i32 = 67;
pub const PAM_BPC_ERROR: i32 = 68;
pub const PAM_BPC_PROMPT: i32 = 69;
pub const PAM_BPC_PASS: i32 = 70;
pub const PAM_PRELIM_CHECK: i32 = 16384;
pub const PAM_UPDATE_AUTHTOK: i32 = 8192;
pub const PAM_DATA_REPLACE: i32 = 536870912;
pub const PAM_MODUTIL_NGROUPS: i32 = 64;
pub type pam_handle_t = u8;
extern "C" {
    pub fn pam_set_item(
        pamh: *mut pam_handle_t,
        item_type: libc::c_int,
        item: *const libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pam_get_item(
        pamh: *const pam_handle_t,
        item_type: libc::c_int,
        item: *mut *const libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pam_strerror(pamh: *mut pam_handle_t, errnum: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    pub fn pam_putenv(pamh: *mut pam_handle_t, name_value: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn pam_getenv(pamh: *mut pam_handle_t, name: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn pam_getenvlist(pamh: *mut pam_handle_t) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn pam_fail_delay(pamh: *mut pam_handle_t, musec_delay: libc::c_uint) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pam_message {
    pub msg_style: libc::c_int,
    pub msg: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_pam_message() {
    const UNINIT: ::std::mem::MaybeUninit<pam_message> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pam_message>(),
        16usize,
        concat!("Size of: ", stringify!(pam_message))
    );
    assert_eq!(
        ::std::mem::align_of::<pam_message>(),
        8usize,
        concat!("Alignment of ", stringify!(pam_message))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_style) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pam_message),
            "::",
            stringify!(msg_style)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pam_message),
            "::",
            stringify!(msg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pam_response {
    pub resp: *mut libc::c_char,
    pub resp_retcode: libc::c_int,
}
#[test]
fn bindgen_test_layout_pam_response() {
    const UNINIT: ::std::mem::MaybeUninit<pam_response> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pam_response>(),
        16usize,
        concat!("Size of: ", stringify!(pam_response))
    );
    assert_eq!(
        ::std::mem::align_of::<pam_response>(),
        8usize,
        concat!("Alignment of ", stringify!(pam_response))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pam_response),
            "::",
            stringify!(resp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resp_retcode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pam_response),
            "::",
            stringify!(resp_retcode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pam_conv {
    pub conv: ::std::option::Option<
        unsafe extern "C" fn(
            num_msg: libc::c_int,
            msg: *mut *const pam_message,
            resp: *mut *mut pam_response,
            appdata_ptr: *mut libc::c_void,
        ) -> libc::c_int,
    >,
    pub appdata_ptr: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_pam_conv() {
    const UNINIT: ::std::mem::MaybeUninit<pam_conv> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pam_conv>(),
        16usize,
        concat!("Size of: ", stringify!(pam_conv))
    );
    assert_eq!(
        ::std::mem::align_of::<pam_conv>(),
        8usize,
        concat!("Alignment of ", stringify!(pam_conv))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pam_conv),
            "::",
            stringify!(conv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).appdata_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pam_conv),
            "::",
            stringify!(appdata_ptr)
        )
    );
}
extern "C" {
    pub fn pam_start(
        service_name: *const libc::c_char,
        user: *const libc::c_char,
        pam_conversation: *const pam_conv,
        pamh: *mut *mut pam_handle_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pam_start_confdir(
        service_name: *const libc::c_char,
        user: *const libc::c_char,
        pam_conversation: *const pam_conv,
        confdir: *const libc::c_char,
        pamh: *mut *mut pam_handle_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pam_end(pamh: *mut pam_handle_t, pam_status: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pam_authenticate(pamh: *mut pam_handle_t, flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pam_setcred(pamh: *mut pam_handle_t, flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pam_acct_mgmt(pamh: *mut pam_handle_t, flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pam_open_session(pamh: *mut pam_handle_t, flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pam_close_session(pamh: *mut pam_handle_t, flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pam_chauthtok(pamh: *mut pam_handle_t, flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pam_get_authtok(
        pamh: *mut pam_handle_t,
        item: libc::c_int,
        authtok: *mut *const libc::c_char,
        prompt: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pam_get_authtok_noverify(
        pamh: *mut pam_handle_t,
        authtok: *mut *const libc::c_char,
        prompt: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pam_get_authtok_verify(
        pamh: *mut pam_handle_t,
        authtok: *mut *const libc::c_char,
        prompt: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pam_misc_paste_env(
        pamh: *mut pam_handle_t,
        user_env: *const *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pam_misc_drop_env(env: *mut *mut libc::c_char) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn pam_misc_setenv(
        pamh: *mut pam_handle_t,
        name: *const libc::c_char,
        value: *const libc::c_char,
        readonly: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pam_set_data(
        pamh: *mut pam_handle_t,
        module_data_name: *const libc::c_char,
        data: *mut libc::c_void,
        cleanup: ::std::option::Option<
            unsafe extern "C" fn(
                pamh: *mut pam_handle_t,
                data: *mut libc::c_void,
                error_status: libc::c_int,
            ),
        >,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pam_get_data(
        pamh: *const pam_handle_t,
        module_data_name: *const libc::c_char,
        data: *mut *const libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pam_get_user(
        pamh: *mut pam_handle_t,
        user: *mut *const libc::c_char,
        prompt: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pam_sm_authenticate(
        pamh: *mut pam_handle_t,
        flags: libc::c_int,
        argc: libc::c_int,
        argv: *mut *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pam_sm_setcred(
        pamh: *mut pam_handle_t,
        flags: libc::c_int,
        argc: libc::c_int,
        argv: *mut *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pam_sm_acct_mgmt(
        pamh: *mut pam_handle_t,
        flags: libc::c_int,
        argc: libc::c_int,
        argv: *mut *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pam_sm_open_session(
        pamh: *mut pam_handle_t,
        flags: libc::c_int,
        argc: libc::c_int,
        argv: *mut *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pam_sm_close_session(
        pamh: *mut pam_handle_t,
        flags: libc::c_int,
        argc: libc::c_int,
        argv: *mut *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pam_sm_chauthtok(
        pamh: *mut pam_handle_t,
        flags: libc::c_int,
        argc: libc::c_int,
        argv: *mut *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pam_modutil_check_user_in_passwd(
        pamh: *mut pam_handle_t,
        user_name: *const libc::c_char,
        file_name: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pam_modutil_getpwnam(pamh: *mut pam_handle_t, user: *const libc::c_char) -> *mut passwd;
}
extern "C" {
    pub fn pam_modutil_getpwuid(pamh: *mut pam_handle_t, uid: uid_t) -> *mut passwd;
}
extern "C" {
    pub fn pam_modutil_getgrnam(pamh: *mut pam_handle_t, group: *const libc::c_char) -> *mut group;
}
extern "C" {
    pub fn pam_modutil_getgrgid(pamh: *mut pam_handle_t, gid: gid_t) -> *mut group;
}
extern "C" {
    pub fn pam_modutil_getspnam(pamh: *mut pam_handle_t, user: *const libc::c_char) -> *mut spwd;
}
extern "C" {
    pub fn pam_modutil_user_in_group_nam_nam(
        pamh: *mut pam_handle_t,
        user: *const libc::c_char,
        group: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pam_modutil_user_in_group_nam_gid(
        pamh: *mut pam_handle_t,
        user: *const libc::c_char,
        group: gid_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pam_modutil_user_in_group_uid_nam(
        pamh: *mut pam_handle_t,
        user: uid_t,
        group: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pam_modutil_user_in_group_uid_gid(
        pamh: *mut pam_handle_t,
        user: uid_t,
        group: gid_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pam_modutil_getlogin(pamh: *mut pam_handle_t) -> *const libc::c_char;
}
extern "C" {
    pub fn pam_modutil_read(
        fd: libc::c_int,
        buffer: *mut libc::c_char,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pam_modutil_write(
        fd: libc::c_int,
        buffer: *const libc::c_char,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pam_modutil_audit_write(
        pamh: *mut pam_handle_t,
        type_: libc::c_int,
        message: *const libc::c_char,
        retval: libc::c_int,
    ) -> libc::c_int;
}
#[repr(C)]
pub struct pam_modutil_privs {
    pub grplist: *mut gid_t,
    pub number_of_groups: libc::c_int,
    pub allocated: libc::c_int,
    pub old_gid: gid_t,
    pub old_uid: uid_t,
    pub is_dropped: libc::c_int,
}
#[test]
fn bindgen_test_layout_pam_modutil_privs() {
    const UNINIT: ::std::mem::MaybeUninit<pam_modutil_privs> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pam_modutil_privs>(),
        32usize,
        concat!("Size of: ", stringify!(pam_modutil_privs))
    );
    assert_eq!(
        ::std::mem::align_of::<pam_modutil_privs>(),
        8usize,
        concat!("Alignment of ", stringify!(pam_modutil_privs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grplist) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pam_modutil_privs),
            "::",
            stringify!(grplist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).number_of_groups) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pam_modutil_privs),
            "::",
            stringify!(number_of_groups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocated) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pam_modutil_privs),
            "::",
            stringify!(allocated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).old_gid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pam_modutil_privs),
            "::",
            stringify!(old_gid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).old_uid) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pam_modutil_privs),
            "::",
            stringify!(old_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_dropped) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pam_modutil_privs),
            "::",
            stringify!(is_dropped)
        )
    );
}
extern "C" {
    pub fn pam_modutil_drop_priv(
        pamh: *mut pam_handle_t,
        p: *mut pam_modutil_privs,
        pw: *const passwd,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pam_modutil_regain_priv(
        pamh: *mut pam_handle_t,
        p: *mut pam_modutil_privs,
    ) -> libc::c_int;
}
pub const pam_modutil_redirect_fd_PAM_MODUTIL_IGNORE_FD: pam_modutil_redirect_fd = 0;
pub const pam_modutil_redirect_fd_PAM_MODUTIL_PIPE_FD: pam_modutil_redirect_fd = 1;
pub const pam_modutil_redirect_fd_PAM_MODUTIL_NULL_FD: pam_modutil_redirect_fd = 2;
pub type pam_modutil_redirect_fd = libc::c_uint;
extern "C" {
    pub fn pam_modutil_sanitize_helper_fds(
        pamh: *mut pam_handle_t,
        redirect_stdin: pam_modutil_redirect_fd,
        redirect_stdout: pam_modutil_redirect_fd,
        redirect_stderr: pam_modutil_redirect_fd,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @brief Lookup a value for the key in the file (i.e. login.defs or a similar\n key-value format file).\n\n @param[in] pamh The pam handle structure\n @param[in] file_name Configuration file name\n @param[in] key Lookup key\n\n @return value, or NULL if key was not found."]
    pub fn pam_modutil_search_key(
        pamh: *mut pam_handle_t,
        file_name: *const libc::c_char,
        key: *const libc::c_char,
    ) -> *mut libc::c_char;
}
